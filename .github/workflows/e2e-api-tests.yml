name: E2E API Tests

on:
  pull_request:
    paths:
      - 'backend/**'
  push:
    branches:
      - main        # DEV environment
      - staging     # STAGING environment
      - PRODUCTION  # PRODUCTION environment
    paths:
      - 'backend/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        type: choice
        options:
          - dev
          - staging
          - production
        default: 'dev'
      test_filter:
        description: 'pytest filter expression (optional)'
        required: false
        type: string
      api_url:
        description: 'API base URL (overrides environment selection)'
        required: false
        type: string
  workflow_run:
    workflows: ["Build, push and deploy"]
    types:
      - completed
    branches:
      - main
      - staging
      - PRODUCTION

jobs:
  e2e-tests:
    runs-on: ubuntu-latest
    # Only run if:
    # - workflow_run: deployment completed successfully
    # - push to main/staging/PRODUCTION: run directly
    # - pull_request: always run
    # - workflow_dispatch: manual trigger
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/PRODUCTION')) ||
      (github.event_name == 'pull_request') ||
      (github.event_name == 'workflow_dispatch')
    
    steps:
      - name: Determine environment
        id: env
        run: |
          # If api_url is explicitly provided, use it
          if [ -n "${{ github.event.inputs.api_url }}" ]; then
            echo "environment=custom" >> $GITHUB_OUTPUT
            echo "api_url=${{ github.event.inputs.api_url }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Manual trigger with environment selection
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "api_url=https://api.kortix.com" >> $GITHUB_OUTPUT
            exit 0
          elif [ "${{ github.event.inputs.environment }}" = "staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "api_url=https://staging-api.suna.so" >> $GITHUB_OUTPUT
            exit 0
          elif [ "${{ github.event.inputs.environment }}" = "dev" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "api_url=https://dev-api.suna.so" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Determine environment from branch
          BRANCH_REF="${{ github.ref }}"
          WORKFLOW_RUN_BRANCH="${{ github.event.workflow_run.head_branch }}"
          
          # Use workflow_run branch if available, otherwise use ref
          if [ -n "$WORKFLOW_RUN_BRANCH" ]; then
            BRANCH="$WORKFLOW_RUN_BRANCH"
          else
            BRANCH="${BRANCH_REF#refs/heads/}"
          fi
          
          echo "Detected branch: $BRANCH"
          
          # PRODUCTION branch ‚Üí production environment
          if [ "$BRANCH" = "PRODUCTION" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "api_url=https://api.kortix.com" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # staging branch ‚Üí staging environment
          if [ "$BRANCH" = "staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "api_url=https://staging-api.suna.so" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # main branch or PRs targeting main ‚Üí dev environment
          if [ "$BRANCH" = "main" ] || [ "${{ github.base_ref }}" = "main" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "api_url=https://dev-api.suna.so" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Default to dev
          echo "environment=dev" >> $GITHUB_OUTPUT
          echo "api_url=https://dev-api.suna.so" >> $GITHUB_OUTPUT
      
      - name: Trigger E2E tests via API
        env:
          API_URL: ${{ steps.env.outputs.api_url }}
          ADMIN_API_KEY: ${{ steps.env.outputs.environment == 'production' && secrets.PRODUCTION_KORTIX_ADMIN_API_KEY || (steps.env.outputs.environment == 'staging' && secrets.STAGING_KORTIX_ADMIN_API_KEY || secrets.DEV_KORTIX_ADMIN_API_KEY) }}
          ENVIRONMENT: ${{ steps.env.outputs.environment }}
        run: |
          set -e
          
          # Validate admin API key is configured
          if [ -z "$ADMIN_API_KEY" ]; then
            case "$ENVIRONMENT" in
              production)
                echo "‚ùå Error: PRODUCTION_KORTIX_ADMIN_API_KEY is not set"
                ;;
              staging)
                echo "‚ùå Error: STAGING_KORTIX_ADMIN_API_KEY is not set"
                ;;
              *)
                echo "‚ùå Error: DEV_KORTIX_ADMIN_API_KEY is not set"
                ;;
            esac
            echo "Please add it at: https://github.com/${{ github.repository }}/settings/secrets/actions"
            exit 1
          fi
          
          # Mask secrets
          echo "::add-mask::$ADMIN_API_KEY"
          
          # Ensure API_URL has /v1 path
          if [[ "$API_URL" != */v1 ]]; then
            API_URL="${API_URL}/v1"
          fi
          
          TEST_FILTER="${{ github.event.inputs.test_filter || '' }}"
          
          echo "üß™ Starting E2E tests"
          echo "üìç Environment: ${{ steps.env.outputs.environment }}"
          echo "üìç API URL: $API_URL"
          if [ -n "$TEST_FILTER" ]; then
            echo "üîç Test filter: $TEST_FILTER"
          fi
          echo ""
          
          # Wait for deployment to complete based on environment
          case "$ENVIRONMENT" in
            production)
              echo "‚è≥ Waiting 6 minutes for production deployment to complete..."
              sleep 360
              ;;
            staging)
              echo "‚è≥ Waiting 3 minutes for staging deployment to complete..."
              sleep 180
              ;;
            *)
              echo "‚è≥ Waiting 2 minutes for dev deployment to complete..."
              sleep 120
              ;;
          esac
          echo "‚úÖ Wait complete, proceeding with tests"
          echo ""
          
          # Build request URL
          if [ -n "$TEST_FILTER" ]; then
            REQUEST_URL="$API_URL/admin/tests/e2e?test_filter=$TEST_FILTER"
          else
            REQUEST_URL="$API_URL/admin/tests/e2e"
          fi
          
          # Make API request with detailed error handling
          HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" --max-time 900 -X POST "$REQUEST_URL" \
            -H "X-Admin-Api-Key: $ADMIN_API_KEY" \
            -H "Content-Type: application/json" 2>&1)
          
          # Extract HTTP status code and body
          HTTP_STATUS=$(echo "$HTTP_RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')
          
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "‚ùå Failed to trigger E2E tests (HTTP $HTTP_STATUS)"
            echo ""
            echo "Response body:"
            echo "$RESPONSE_BODY" | jq '.' 2>/dev/null || echo "$RESPONSE_BODY"
            echo ""
            echo "üîç Troubleshooting:"
            echo "  1. Verify API URL is correct: $API_URL"
            echo "  2. Check that the admin API key is valid for $ENVIRONMENT"
            echo "  3. Ensure the API server is running and accessible"
            echo "  4. Check API server logs for more details"
            exit 1
          fi
          
          echo "‚úÖ E2E tests completed"
          echo ""
          echo "API Response:"
          echo "$RESPONSE_BODY" | jq '.' 2>/dev/null || echo "$RESPONSE_BODY"
          echo ""
          
          # Extract test status from response
          TEST_STATUS=$(echo "$RESPONSE_BODY" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
          TEST_RETURNCODE=$(echo "$RESPONSE_BODY" | jq -r '.returncode // -1' 2>/dev/null || echo "-1")
          
          # Create summary
          echo "## E2E Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **API URL**: $API_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: $TEST_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **Return Code**: $TEST_RETURNCODE" >> $GITHUB_STEP_SUMMARY
          if [ -n "$TEST_FILTER" ]; then
            echo "- **Test Filter**: \`$TEST_FILTER\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add test output
          echo "### Test Output:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "$RESPONSE_BODY" | jq -r '.stdout // ""' 2>/dev/null >> $GITHUB_STEP_SUMMARY || echo "$RESPONSE_BODY" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          
          # Exit with test return code
          if [ "$TEST_STATUS" = "passed" ] && [ "$TEST_RETURNCODE" = "0" ]; then
            echo "‚úÖ All tests passed"
            exit 0
          elif [ "$TEST_STATUS" = "timeout" ]; then
            echo "‚ùå Tests timed out"
            exit 1
          elif [ "$TEST_STATUS" = "failed" ]; then
            echo "‚ùå Tests failed (return code: $TEST_RETURNCODE)"
            exit 1
          else
            echo "‚ö†Ô∏è  Unknown test status: $TEST_STATUS"
            exit 1
          fi
